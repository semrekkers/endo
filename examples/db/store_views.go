// Code generated by endogen; DO NOT EDIT.

package db

import (
	"context"
	"database/sql"

	"github.com/semrekkers/endo/pkg/endo"
)

const (
	// querySelectEffectiveRole is a prepared SQL query for selecting a EffectiveRole.
	querySelectEffectiveRole = `SELECT role_id, role_name FROM effective_roles `
	// queryReturnEffectiveRole can be used as a part of a SQL query for returning a EffectiveRole.
	queryReturnEffectiveRole = ` RETURNING role_id, role_name`
	// querySortEffectiveRole is the default sorting order of EffectiveRole.
	querySortEffectiveRole = ` ORDER BY user_id, role_id `
)

// GetEffectiveRole retrieves the first EffectiveRole with the filters applied. The default sorting of EffectiveRole is used.
func (s *Store) GetEffectiveRole(ctx context.Context, filters ...endo.KeyValue) (*EffectiveRole, error) {
	var qb endo.Builder
	qb.Write(querySelectEffectiveRole)
	if 0 < len(filters) {
		qb.Write("WHERE ").WriteKeyValues("(%s)", " AND ", filters...).Write(" ")
	}
	qb.Write(querySortEffectiveRole + "LIMIT 1")
	query, args := qb.Build()

	var e EffectiveRole
	err := s.TX(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query, args...)
		return scanEffectiveRole(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// GetEffectiveRoles retrieves all EffectiveRoles with the filters applied, within the bounds of the page.
// The default sorting of EffectiveRole is used.
func (s *Store) GetEffectiveRoles(ctx context.Context, po endo.PageOptions, filters ...endo.KeyValue) ([]*EffectiveRole, error) {
	var qb endo.Builder
	qb.Write(querySelectEffectiveRole)
	if 0 < len(filters) {
		qb.Write("WHERE ").WriteKeyValues("(%s)", " AND ", filters...).Write(" ")
	}
	qb.Write(querySortEffectiveRole)
	limit, offset := po.Args()
	qb.WriteWithParams("LIMIT {} OFFSET {}", limit, offset)
	query, args := qb.Build()

	var c []*EffectiveRole
	err := s.TX(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		rows, err := dbtx.QueryContext(ctx, query, args...)
		if err != nil {
			return err
		}
		defer rows.Close()
		c, err = scanEffectiveRoleRows(rows)
		return err
	})

	return c, err
}

// scanEffectiveRole scans a single EffectiveRole passed by e, using scanner s.
// This works best if querySelectEffectiveRole is used as query.
func scanEffectiveRole(e *EffectiveRole, s endo.Scanner) error {
	return s.Scan(
		&e.RoleID,
		&e.RoleName,
	)
}

// scanEffectiveRoleRows scans all EffectiveRoles using scanner s, and returns the results.
// This works best if querySelectEffectiveRole is used as query.
func scanEffectiveRoleRows(rows *sql.Rows) ([]*EffectiveRole, error) {
	var c []*EffectiveRole
	for rows.Next() {
		var e EffectiveRole
		if err := scanEffectiveRole(&e, rows); err != nil {
			return nil, err
		}
		c = append(c, &e)
	}
	return c, nil
}
