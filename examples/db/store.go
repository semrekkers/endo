// Code generated by endogen; DO NOT EDIT.

package db

import (
	"context"
	"database/sql"

	"github.com/semrekkers/endo/pkg/endo"

	"time"
)

// Store manages the set of APIs for database access.
type Store struct {
	tx endo.TxFunc
}

// NewStore creates a new Store.
func NewStore(tx endo.TxFunc) *Store {
	return &Store{
		tx: tx,
	}
}

const (
	querySelectUser    = `SELECT id, email, first_name, last_name, display_name, email_verified, password_hash, created_at, updated_at FROM users `
	queryReturningUser = ` RETURNING id, email, first_name, last_name, display_name, email_verified, password_hash, created_at, updated_at`
)

// GetUser finds the User identified by the given key.
func (s *Store) GetUser(ctx context.Context, key int) (*User, error) {
	const query = querySelectUser + "WHERE id = $1"

	var e User
	err := s.tx(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query, key)
		return scanUser(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// GetUserByField finds the User where field equals v.
// Please be aware that field is not protected against SQL injection attacks.
func (s *Store) GetUserByField(ctx context.Context, field string, v interface{}) (*User, error) {
	var qb endo.Builder
	query := qb.
		Write(querySelectUser).
		Writef("WHERE %s = $1", field).
		String()

	var e User
	err := s.tx(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query, v)
		return scanUser(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// GetUsers gets all Users from the database.
func (s *Store) GetUsers(ctx context.Context, po endo.PageOptions) ([]*User, error) {
	const query = querySelectUser + "ORDER BY id " + "LIMIT $1 OFFSET $2"
	limit, offset := po.Args()

	var c []*User
	err := s.tx(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		rows, err := dbtx.QueryContext(ctx, query, limit, offset)
		if err != nil {
			return err
		}
		defer rows.Close()
		c, err = scanUserRows(rows)
		return err
	})
	if err != nil {
		return nil, err
	}

	return c, nil
}

// CreateUser adds User to the database. It returns the created User.
func (s *Store) CreateUser(ctx context.Context, e User) (*User, error) {
	const query = `INSERT INTO users (email, first_name, last_name, email_verified, password_hash, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7) ` +
		queryReturningUser

	err := s.tx(ctx, endo.TxMutation, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query,
			e.Email,
			e.FirstName,
			e.LastName,
			e.EmailVerified,
			e.PasswordHash,
			e.CreatedAt,
			e.UpdatedAt,
		)
		return scanUser(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// UpdateUser updates the User identified by the given key.
func (s *Store) UpdateUser(ctx context.Context, key int, e User) (*User, error) {
	const query = `UPDATE users SET email = $1, first_name = $2, last_name = $3, email_verified = $4, password_hash = $5, created_at = $6, updated_at = $7 WHERE id = $8 ` +
		queryReturningUser

	err := s.tx(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query,
			e.Email,
			e.FirstName,
			e.LastName,
			e.EmailVerified,
			e.PasswordHash,
			e.CreatedAt,
			e.UpdatedAt,
			key,
		)
		return scanUser(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// UpdateUserByField updates the User to the given e where field equals v.
// Please be aware that field is not protected against SQL injection attacks.
func (s *Store) UpdateUserByField(ctx context.Context, field string, v interface{}, e User) (*User, error) {
	var qb endo.Builder
	query := qb.
		Write(`UPDATE users SET email = $1, first_name = $2, last_name = $3, email_verified = $4, password_hash = $5, created_at = $6, updated_at = $7 `).
		Writef("WHERE %s = $8 ", field).
		Write(queryReturningUser).
		String()

	err := s.tx(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query,
			e.Email,
			e.FirstName,
			e.LastName,
			e.EmailVerified,
			e.PasswordHash,
			e.CreatedAt,
			e.UpdatedAt,
			v,
		)
		return scanUser(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// UserPatch can (partially) patch a User.
type UserPatch struct {
	Email         *string
	FirstName     *sql.NullString
	LastName      *sql.NullString
	EmailVerified *bool
	PasswordHash  *sql.NullString
	CreatedAt     *time.Time
	UpdatedAt     *time.Time
}

// PatchUser updates the User identified by the given key, using the patch p.
func (s *Store) PatchUser(ctx context.Context, key int, p UserPatch) (*User, error) {
	var fieldUpdates []endo.NamedArg

	if p.Email != nil {
		fieldUpdates = append(fieldUpdates, endo.NamedArg{
			Name:  "email",
			Value: *p.Email,
		})
	}
	if p.FirstName != nil {
		fieldUpdates = append(fieldUpdates, endo.NamedArg{
			Name:  "first_name",
			Value: *p.FirstName,
		})
	}
	if p.LastName != nil {
		fieldUpdates = append(fieldUpdates, endo.NamedArg{
			Name:  "last_name",
			Value: *p.LastName,
		})
	}
	if p.EmailVerified != nil {
		fieldUpdates = append(fieldUpdates, endo.NamedArg{
			Name:  "email_verified",
			Value: *p.EmailVerified,
		})
	}
	if p.PasswordHash != nil {
		fieldUpdates = append(fieldUpdates, endo.NamedArg{
			Name:  "password_hash",
			Value: *p.PasswordHash,
		})
	}
	if p.CreatedAt != nil {
		fieldUpdates = append(fieldUpdates, endo.NamedArg{
			Name:  "created_at",
			Value: *p.CreatedAt,
		})
	}
	if p.UpdatedAt != nil {
		fieldUpdates = append(fieldUpdates, endo.NamedArg{
			Name:  "updated_at",
			Value: *p.UpdatedAt,
		})
	}
	if len(fieldUpdates) == 0 {
		return nil, endo.ErrNoChange
	}

	var qb endo.Builder
	query, args := qb.
		Write("UPDATE users SET ").
		WriteNamedArgs("%s = {}", ", ", fieldUpdates...).
		WriteWithParams(" WHERE id = {} ", key).
		Write(queryReturningUser).
		Build()

	var e User
	err := s.tx(ctx, endo.TxMutation, func(dbtx endo.DBTX) error {
		return scanUser(&e, dbtx.QueryRowContext(ctx, query, args...))
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// PatchUserByField updates the User using the given patch p where field equals v.
// Please be aware that field is not protected against SQL injection attacks.
func (s *Store) PatchUserByField(ctx context.Context, field string, v interface{}, p UserPatch) (*User, error) {
	var fieldUpdates []endo.NamedArg

	if p.Email != nil {
		fieldUpdates = append(fieldUpdates, endo.NamedArg{
			Name:  "email",
			Value: *p.Email,
		})
	}
	if p.FirstName != nil {
		fieldUpdates = append(fieldUpdates, endo.NamedArg{
			Name:  "first_name",
			Value: *p.FirstName,
		})
	}
	if p.LastName != nil {
		fieldUpdates = append(fieldUpdates, endo.NamedArg{
			Name:  "last_name",
			Value: *p.LastName,
		})
	}
	if p.EmailVerified != nil {
		fieldUpdates = append(fieldUpdates, endo.NamedArg{
			Name:  "email_verified",
			Value: *p.EmailVerified,
		})
	}
	if p.PasswordHash != nil {
		fieldUpdates = append(fieldUpdates, endo.NamedArg{
			Name:  "password_hash",
			Value: *p.PasswordHash,
		})
	}
	if p.CreatedAt != nil {
		fieldUpdates = append(fieldUpdates, endo.NamedArg{
			Name:  "created_at",
			Value: *p.CreatedAt,
		})
	}
	if p.UpdatedAt != nil {
		fieldUpdates = append(fieldUpdates, endo.NamedArg{
			Name:  "updated_at",
			Value: *p.UpdatedAt,
		})
	}
	if len(fieldUpdates) == 0 {
		return nil, endo.ErrNoChange
	}

	var qb endo.Builder
	query, args := qb.
		Write("UPDATE users SET ").
		WriteNamedArgs("%s = {}", ", ", fieldUpdates...).
		Writef(" WHERE %s", field).WriteWithParams(" = {} ", v).
		Write(queryReturningUser).
		Build()

	var e User
	err := s.tx(ctx, endo.TxMutation, func(dbtx endo.DBTX) error {
		return scanUser(&e, dbtx.QueryRowContext(ctx, query, args...))
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// DeleteUser deletes the User identified by the given key.
func (s *Store) DeleteUser(ctx context.Context, key int) error {
	const query = "DELETE FROM users WHERE id = $1"

	return s.tx(ctx, endo.TxMutation, func(dbtx endo.DBTX) error {
		_, err := dbtx.ExecContext(ctx, query, key)
		return err
	})
}

// DeleteUserByField deletes the User where field equals v.
// Please be aware that field is not protected against SQL injection attacks.
func (s *Store) DeleteUserByField(ctx context.Context, field string, v interface{}) error {
	var qb endo.Builder
	query := qb.
		Write("DELETE FROM users").
		Writef(" WHERE %s = $1", field).
		String()
	return s.tx(ctx, endo.TxMutation, func(dbtx endo.DBTX) error {
		_, err := dbtx.ExecContext(ctx, query, v)
		return err
	})
}

func scanUser(e *User, s endo.Scanner) error {
	return s.Scan(
		&e.ID,
		&e.Email,
		&e.FirstName,
		&e.LastName,
		&e.DisplayName,
		&e.EmailVerified,
		&e.PasswordHash,
		&e.CreatedAt,
		&e.UpdatedAt,
	)
}

func scanUserRows(rows *sql.Rows) ([]*User, error) {
	var c []*User
	for rows.Next() {
		var e User
		if err := scanUser(&e, rows); err != nil {
			return nil, err
		}
		c = append(c, &e)
	}
	return c, nil
}

const (
	querySelectRole    = `SELECT id, name FROM roles `
	queryReturningRole = ` RETURNING id, name`
)

// GetRole finds the Role identified by the given key.
func (s *Store) GetRole(ctx context.Context, key int) (*Role, error) {
	const query = querySelectRole + "WHERE id = $1"

	var e Role
	err := s.tx(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query, key)
		return scanRole(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// GetRoleByField finds the Role where field equals v.
// Please be aware that field is not protected against SQL injection attacks.
func (s *Store) GetRoleByField(ctx context.Context, field string, v interface{}) (*Role, error) {
	var qb endo.Builder
	query := qb.
		Write(querySelectRole).
		Writef("WHERE %s = $1", field).
		String()

	var e Role
	err := s.tx(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query, v)
		return scanRole(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// GetRoles gets all Roles from the database.
func (s *Store) GetRoles(ctx context.Context, po endo.PageOptions) ([]*Role, error) {
	const query = querySelectRole + "ORDER BY id " + "LIMIT $1 OFFSET $2"
	limit, offset := po.Args()

	var c []*Role
	err := s.tx(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		rows, err := dbtx.QueryContext(ctx, query, limit, offset)
		if err != nil {
			return err
		}
		defer rows.Close()
		c, err = scanRoleRows(rows)
		return err
	})
	if err != nil {
		return nil, err
	}

	return c, nil
}

// CreateRole adds Role to the database. It returns the created Role.
func (s *Store) CreateRole(ctx context.Context, e Role) (*Role, error) {
	const query = `INSERT INTO roles (name) VALUES ($1) ` +
		queryReturningRole

	err := s.tx(ctx, endo.TxMutation, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query,
			e.Name,
		)
		return scanRole(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// UpdateRole updates the Role identified by the given key.
func (s *Store) UpdateRole(ctx context.Context, key int, e Role) (*Role, error) {
	const query = `UPDATE roles SET name = $1 WHERE id = $2 ` +
		queryReturningRole

	err := s.tx(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query,
			e.Name,
			key,
		)
		return scanRole(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// UpdateRoleByField updates the Role to the given e where field equals v.
// Please be aware that field is not protected against SQL injection attacks.
func (s *Store) UpdateRoleByField(ctx context.Context, field string, v interface{}, e Role) (*Role, error) {
	var qb endo.Builder
	query := qb.
		Write(`UPDATE roles SET name = $1 `).
		Writef("WHERE %s = $2 ", field).
		Write(queryReturningRole).
		String()

	err := s.tx(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query,
			e.Name,
			v,
		)
		return scanRole(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// RolePatch can (partially) patch a Role.
type RolePatch struct {
	Name *string
}

// PatchRole updates the Role identified by the given key, using the patch p.
func (s *Store) PatchRole(ctx context.Context, key int, p RolePatch) (*Role, error) {
	var fieldUpdates []endo.NamedArg

	if p.Name != nil {
		fieldUpdates = append(fieldUpdates, endo.NamedArg{
			Name:  "name",
			Value: *p.Name,
		})
	}
	if len(fieldUpdates) == 0 {
		return nil, endo.ErrNoChange
	}

	var qb endo.Builder
	query, args := qb.
		Write("UPDATE roles SET ").
		WriteNamedArgs("%s = {}", ", ", fieldUpdates...).
		WriteWithParams(" WHERE id = {} ", key).
		Write(queryReturningRole).
		Build()

	var e Role
	err := s.tx(ctx, endo.TxMutation, func(dbtx endo.DBTX) error {
		return scanRole(&e, dbtx.QueryRowContext(ctx, query, args...))
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// PatchRoleByField updates the Role using the given patch p where field equals v.
// Please be aware that field is not protected against SQL injection attacks.
func (s *Store) PatchRoleByField(ctx context.Context, field string, v interface{}, p RolePatch) (*Role, error) {
	var fieldUpdates []endo.NamedArg

	if p.Name != nil {
		fieldUpdates = append(fieldUpdates, endo.NamedArg{
			Name:  "name",
			Value: *p.Name,
		})
	}
	if len(fieldUpdates) == 0 {
		return nil, endo.ErrNoChange
	}

	var qb endo.Builder
	query, args := qb.
		Write("UPDATE roles SET ").
		WriteNamedArgs("%s = {}", ", ", fieldUpdates...).
		Writef(" WHERE %s", field).WriteWithParams(" = {} ", v).
		Write(queryReturningRole).
		Build()

	var e Role
	err := s.tx(ctx, endo.TxMutation, func(dbtx endo.DBTX) error {
		return scanRole(&e, dbtx.QueryRowContext(ctx, query, args...))
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// DeleteRole deletes the Role identified by the given key.
func (s *Store) DeleteRole(ctx context.Context, key int) error {
	const query = "DELETE FROM roles WHERE id = $1"

	return s.tx(ctx, endo.TxMutation, func(dbtx endo.DBTX) error {
		_, err := dbtx.ExecContext(ctx, query, key)
		return err
	})
}

// DeleteRoleByField deletes the Role where field equals v.
// Please be aware that field is not protected against SQL injection attacks.
func (s *Store) DeleteRoleByField(ctx context.Context, field string, v interface{}) error {
	var qb endo.Builder
	query := qb.
		Write("DELETE FROM roles").
		Writef(" WHERE %s = $1", field).
		String()
	return s.tx(ctx, endo.TxMutation, func(dbtx endo.DBTX) error {
		_, err := dbtx.ExecContext(ctx, query, v)
		return err
	})
}

func scanRole(e *Role, s endo.Scanner) error {
	return s.Scan(
		&e.ID,
		&e.Name,
	)
}

func scanRoleRows(rows *sql.Rows) ([]*Role, error) {
	var c []*Role
	for rows.Next() {
		var e Role
		if err := scanRole(&e, rows); err != nil {
			return nil, err
		}
		c = append(c, &e)
	}
	return c, nil
}
