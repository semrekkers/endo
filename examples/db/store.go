// Code generated by endogen; DO NOT EDIT.

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/semrekkers/endo/pkg/endo"
)

// Store manages the set of APIs for database access.
type Store struct {
	TX endo.TxFunc
}

const (
	querySelectUser = `SELECT id, email, first_name, last_name, display_name, email_verified, password_hash, created_at, updated_at FROM users `
	queryReturnUser = ` RETURNING id, email, first_name, last_name, display_name, email_verified, password_hash, created_at, updated_at`
	querySortUser   = ` ORDER BY id `
)

// GetUser retrieves the first User with the filters applied. The default sorting of User is used.
func (s *Store) GetUser(ctx context.Context, filters ...endo.KeyValue) (*User, error) {
	var qb endo.Builder
	qb.Write(querySelectUser)
	if 0 < len(filters) {
		qb.Write("WHERE ").WriteKeyValues("(%s)", " AND ", filters...).Write(" ")
	}
	qb.Write(querySortUser + "LIMIT 1")
	query, args := qb.Build()

	var e User
	err := s.TX(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query, args...)
		return scanUser(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// GetUsers retrieves all Users with the filters applied, within the bounds of the page.
// The default sorting of User is used.
func (s *Store) GetUsers(ctx context.Context, po endo.PageOptions, filters ...endo.KeyValue) ([]*User, error) {
	var qb endo.Builder
	qb.Write(querySelectUser)
	if 0 < len(filters) {
		qb.Write("WHERE ").WriteKeyValues("(%s)", " AND ", filters...).Write(" ")
	}
	qb.Write(querySortUser)
	limit, offset := po.Args()
	qb.WriteWithParams("LIMIT {} OFFSET {}", limit, offset)
	query, args := qb.Build()

	var c []*User
	err := s.TX(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		rows, err := dbtx.QueryContext(ctx, query, args...)
		if err != nil {
			return err
		}
		defer rows.Close()
		c, err = scanUserRows(rows)
		return err
	})

	return c, err
}

// CreateUser inserts a User record. On success, it returns the created record.
func (s *Store) CreateUser(ctx context.Context, e User) (*User, error) {
	const query = `INSERT INTO users (email, first_name, last_name, email_verified, password_hash, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7) ` +
		queryReturnUser

	err := s.TX(ctx, endo.TxMutation, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query,
			e.Email,
			e.FirstName,
			e.LastName,
			e.EmailVerified,
			e.PasswordHash,
			e.CreatedAt,
			e.UpdatedAt,
		)
		return scanUser(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// UpdateUser updates the first User with the filters applied. The default sorting of User is used.
// On success, it returns the updated record.
func (s *Store) UpdateUser(ctx context.Context, e User, filters ...endo.KeyValue) (*User, error) {
	var qb endo.Builder
	qb.WriteWithArgs(`UPDATE users SET email = $1, first_name = $2, last_name = $3, email_verified = $4, password_hash = $5, created_at = $6, updated_at = $7 `,
		e.Email,
		e.FirstName,
		e.LastName,
		e.EmailVerified,
		e.PasswordHash,
		e.CreatedAt,
		e.UpdatedAt,
	)
	if 0 < len(filters) {
		qb.Write("WHERE ").WriteKeyValues("(%s)", " AND ", filters...).Write(" ")
	}
	qb.Write(querySortUser + "LIMIT 1" + queryReturnUser)
	query, args := qb.Build()

	err := s.TX(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query, args...)
		return scanUser(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// UserPatch (partially) patches: User.
type UserPatch struct {
	Email         *string         `db:"email"`
	FirstName     *sql.NullString `db:"first_name"`
	LastName      *sql.NullString `db:"last_name"`
	EmailVerified *bool           `db:"email_verified"`
	PasswordHash  *sql.NullString `db:"password_hash"`
	CreatedAt     *time.Time      `db:"created_at"`
	UpdatedAt     *time.Time      `db:"updated_at"`
}

// PatchUser updates the first User using patch with the filters applied. The default sorting of User is used.
// On success, it returns the updated record.
func (s *Store) PatchUser(ctx context.Context, p UserPatch, filters ...endo.KeyValue) (*User, error) {
	var fieldUpdates []endo.KeyValue

	if p.Email != nil {
		fieldUpdates = append(fieldUpdates, endo.KeyValue{
			Key:   `email`,
			Value: *p.Email,
		})
	}
	if p.FirstName != nil {
		fieldUpdates = append(fieldUpdates, endo.KeyValue{
			Key:   `first_name`,
			Value: *p.FirstName,
		})
	}
	if p.LastName != nil {
		fieldUpdates = append(fieldUpdates, endo.KeyValue{
			Key:   `last_name`,
			Value: *p.LastName,
		})
	}
	if p.EmailVerified != nil {
		fieldUpdates = append(fieldUpdates, endo.KeyValue{
			Key:   `email_verified`,
			Value: *p.EmailVerified,
		})
	}
	if p.PasswordHash != nil {
		fieldUpdates = append(fieldUpdates, endo.KeyValue{
			Key:   `password_hash`,
			Value: *p.PasswordHash,
		})
	}
	if p.CreatedAt != nil {
		fieldUpdates = append(fieldUpdates, endo.KeyValue{
			Key:   `created_at`,
			Value: *p.CreatedAt,
		})
	}
	if p.UpdatedAt != nil {
		fieldUpdates = append(fieldUpdates, endo.KeyValue{
			Key:   `updated_at`,
			Value: *p.UpdatedAt,
		})
	}
	if len(fieldUpdates) < 1 {
		return nil, endo.ErrEmptyUpdate
	}

	var qb endo.Builder
	qb.Write(`UPDATE users SET `).WriteKeyValues("%s = {}", ", ", fieldUpdates...).Write(" ")
	if 0 < len(filters) {
		qb.Write("WHERE ").WriteKeyValues("(%s)", " AND ", filters...).Write(" ")
	}
	qb.Write(querySortUser + "LIMIT 1" + queryReturnUser)
	query, args := qb.Build()

	var e User
	err := s.TX(ctx, endo.TxMutation, func(dbtx endo.DBTX) error {
		return scanUser(&e, dbtx.QueryRowContext(ctx, query, args...))
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// DeleteUser deletes the first User with the filters applied. The default sorting of User is used.
func (s *Store) DeleteUser(ctx context.Context, filters ...endo.KeyValue) error {
	var qb endo.Builder
	qb.Write(`DELETE FROM users `)
	if 0 < len(filters) {
		qb.Write("WHERE ").WriteKeyValues("(%s)", " AND ", filters...).Write(" ")
	}
	qb.Write(querySortUser + "LIMIT 1")
	query, args := qb.Build()

	return s.TX(ctx, endo.TxMutation, func(dbtx endo.DBTX) error {
		_, err := dbtx.ExecContext(ctx, query, args...)
		return err
	})
}

func scanUser(e *User, s endo.Scanner) error {
	return s.Scan(
		&e.ID,
		&e.Email,
		&e.FirstName,
		&e.LastName,
		&e.DisplayName,
		&e.EmailVerified,
		&e.PasswordHash,
		&e.CreatedAt,
		&e.UpdatedAt,
	)
}

func scanUserRows(rows *sql.Rows) ([]*User, error) {
	var c []*User
	for rows.Next() {
		var e User
		if err := scanUser(&e, rows); err != nil {
			return nil, err
		}
		c = append(c, &e)
	}
	return c, nil
}

const (
	querySelectRole = `SELECT id, name FROM roles `
	queryReturnRole = ` RETURNING id, name`
	querySortRole   = ` ORDER BY id `
)

// GetRole retrieves the first Role with the filters applied. The default sorting of Role is used.
func (s *Store) GetRole(ctx context.Context, filters ...endo.KeyValue) (*Role, error) {
	var qb endo.Builder
	qb.Write(querySelectRole)
	if 0 < len(filters) {
		qb.Write("WHERE ").WriteKeyValues("(%s)", " AND ", filters...).Write(" ")
	}
	qb.Write(querySortRole + "LIMIT 1")
	query, args := qb.Build()

	var e Role
	err := s.TX(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query, args...)
		return scanRole(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// GetRoles retrieves all Roles with the filters applied, within the bounds of the page.
// The default sorting of Role is used.
func (s *Store) GetRoles(ctx context.Context, po endo.PageOptions, filters ...endo.KeyValue) ([]*Role, error) {
	var qb endo.Builder
	qb.Write(querySelectRole)
	if 0 < len(filters) {
		qb.Write("WHERE ").WriteKeyValues("(%s)", " AND ", filters...).Write(" ")
	}
	qb.Write(querySortRole)
	limit, offset := po.Args()
	qb.WriteWithParams("LIMIT {} OFFSET {}", limit, offset)
	query, args := qb.Build()

	var c []*Role
	err := s.TX(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		rows, err := dbtx.QueryContext(ctx, query, args...)
		if err != nil {
			return err
		}
		defer rows.Close()
		c, err = scanRoleRows(rows)
		return err
	})

	return c, err
}

// CreateRole inserts a Role record. On success, it returns the created record.
func (s *Store) CreateRole(ctx context.Context, e Role) (*Role, error) {
	const query = `INSERT INTO roles (name) VALUES ($1) ` +
		queryReturnRole

	err := s.TX(ctx, endo.TxMutation, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query,
			e.Name,
		)
		return scanRole(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// UpdateRole updates the first Role with the filters applied. The default sorting of Role is used.
// On success, it returns the updated record.
func (s *Store) UpdateRole(ctx context.Context, e Role, filters ...endo.KeyValue) (*Role, error) {
	var qb endo.Builder
	qb.WriteWithArgs(`UPDATE roles SET name = $1 `,
		e.Name,
	)
	if 0 < len(filters) {
		qb.Write("WHERE ").WriteKeyValues("(%s)", " AND ", filters...).Write(" ")
	}
	qb.Write(querySortRole + "LIMIT 1" + queryReturnRole)
	query, args := qb.Build()

	err := s.TX(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query, args...)
		return scanRole(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// RolePatch (partially) patches: Role.
type RolePatch struct {
	Name *string `db:"name"`
}

// PatchRole updates the first Role using patch with the filters applied. The default sorting of Role is used.
// On success, it returns the updated record.
func (s *Store) PatchRole(ctx context.Context, p RolePatch, filters ...endo.KeyValue) (*Role, error) {
	var fieldUpdates []endo.KeyValue

	if p.Name != nil {
		fieldUpdates = append(fieldUpdates, endo.KeyValue{
			Key:   `name`,
			Value: *p.Name,
		})
	}
	if len(fieldUpdates) < 1 {
		return nil, endo.ErrEmptyUpdate
	}

	var qb endo.Builder
	qb.Write(`UPDATE roles SET `).WriteKeyValues("%s = {}", ", ", fieldUpdates...).Write(" ")
	if 0 < len(filters) {
		qb.Write("WHERE ").WriteKeyValues("(%s)", " AND ", filters...).Write(" ")
	}
	qb.Write(querySortRole + "LIMIT 1" + queryReturnRole)
	query, args := qb.Build()

	var e Role
	err := s.TX(ctx, endo.TxMutation, func(dbtx endo.DBTX) error {
		return scanRole(&e, dbtx.QueryRowContext(ctx, query, args...))
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// DeleteRole deletes the first Role with the filters applied. The default sorting of Role is used.
func (s *Store) DeleteRole(ctx context.Context, filters ...endo.KeyValue) error {
	var qb endo.Builder
	qb.Write(`DELETE FROM roles `)
	if 0 < len(filters) {
		qb.Write("WHERE ").WriteKeyValues("(%s)", " AND ", filters...).Write(" ")
	}
	qb.Write(querySortRole + "LIMIT 1")
	query, args := qb.Build()

	return s.TX(ctx, endo.TxMutation, func(dbtx endo.DBTX) error {
		_, err := dbtx.ExecContext(ctx, query, args...)
		return err
	})
}

func scanRole(e *Role, s endo.Scanner) error {
	return s.Scan(
		&e.ID,
		&e.Name,
	)
}

func scanRoleRows(rows *sql.Rows) ([]*Role, error) {
	var c []*Role
	for rows.Next() {
		var e Role
		if err := scanRole(&e, rows); err != nil {
			return nil, err
		}
		c = append(c, &e)
	}
	return c, nil
}
