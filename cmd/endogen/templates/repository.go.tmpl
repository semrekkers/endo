// Code generated by endogen; DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"time"

	"github.com/lib/pq"
	"github.com/semrekkers/endo/pkg/endo"
)

// Repository handles actions with the underlying database.
type Repository struct {
	tx endo.TxFunc
}

// NewRepository returns a new Repository.
func NewRepository(txFunc endo.TxFunc) *Repository {
	return &Repository{
		tx: txFunc,
	}
}

{{range .Schema}}

const (
	querySelect{{.Name}} = `{{template "querySelect" .}}`
	queryInsert{{.Name}} = `{{template "queryInsert" .}}`
	queryReturning{{.Name}} = `{{template "queryReturning" .}}`
)

{{if .PrimaryKeyField}}
// Get{{.Name}} retrieves a single {{.Name}} from the database using the primary key.
func (r *Repository) Get{{.Name}}(ctx context.Context, primaryKey {{.PrimaryKeyField.Type}}) (*{{.Name}}, error) {
	const query = querySelect + " WHERE {{.PrimaryKeyField.Column}} = $1"

	var e {{.Name}}
	err := r.tx(ctx, endo.TxReadOnly, func(db endo.DBTX) error {
		row := db.QueryRowContext(ctx, query, primaryKey)
		return scan{{.Name}}(&e, row)
	})
	if err != nil {
		return nil, err
	}

	{{if .InvokeOnRead}}{{.InvokeOnRead}}(ctx, &e){{end}}
	return &e, nil
}
{{end}}

// Get{{.Name}}ByField retrieves a single {{.Name}} from the database with field `byField` equal to `v`.
func (r *Repository) Get{{.Name}}ByField(ctx context.Context, byField string, v interface{}) (*{{.Name}}, error) {
	var e {{.Name}}
	var qb endo.Builder
	query := qb.
		Write(querySelect{{.Name}}).
		Writef(" WHERE %s = $1", pq.QuoteIdentifier(byField)).
		String()
	err := r.tx(ctx, endo.TxReadOnly, func(db endo.DBTX) error {
		row := db.QueryRowContext(ctx, query, v)
		return scan{{.Name}}(&e, row)
	})
	if err != nil {
		return nil, err
	}

	{{if .InvokeOnRead}}{{.InvokeOnRead}}(ctx, &e){{end}}
	return &e, nil
}

// Get{{.Plural}} retrieves paginated {{.Plural}} from the database.
func (r *Repository) Get{{.Plural}}(ctx context.Context, po endo.PageOptions) ([]*{{.Name}}, error) {
	const query = querySelect{{.Name}} +
	{{- if .OrderBy -}}
		" ORDER BY {{ .OrderBy }}" +
	{{- end -}}
	" LIMIT $1 OFFSET $2"

	var c []*{{.Name}}
	limit, offset := po.Args()
	err := r.tx(ctx, endo.TxReadOnly, func(db endo.DBTX) error {
		rows, err := db.QueryContext(ctx, query, limit, offset)
		if err != nil {
			return err
		}
		defer rows.Close()
		for rows.Next() {
			var e {{.Name}}
			if err = scan{{.Name}}(&e, rows); err != nil {
				return err
			}
			c = append(c, &e)
		}
		return nil
	})
	if err != nil {
		return nil, err
	}

	{{if .InvokeOnRead}}
	for _, e := range c {
		{{.InvokeOnRead}}(ctx, &e)
	}
	{{- end}}
	return c, nil
}

{{if not .NoCreate}}
// Create{{.Name}} creates and saves a new {{.Name}}.
func (r *Repository) Create{{.Name}}(ctx context.Context, e {{.Name}}) (*{{.Name}}, error) {
	now := time.Now()
	{{if .CreatedAtField}}e.{{.CreatedAtField.Name}} = now{{end}}
	{{if .UpdatedAtField}}e.{{.UpdatedAtField.Name}} = now{{end}}

	err := r.tx(ctx, endo.TxMutation, func(db endo.DBTX) error {
		return db.QueryRowContext(ctx, queryInsert{{.Name}},
			{{- range .FieldsNoPrimaryKey }}
			e.{{.Name}},
			{{- end }}
		).Scan(
			&e.{{.PrimaryKeyField.Name}},
		)
	})
	if err != nil {
		return nil, err
	}

	{{if .InvokeOnCreate}}{{.InvokeOnCreate}}(ctx, &e){{end}}
	return &e, nil
}
{{end}}

{{if not .NoUpdate}}

{{if .PrimaryKeyField}}
// Update{{.Name}} updates the {{.Name}} using the primary key.
func (r *Repository) Update{{.Name}}(ctx context.Context, primaryKey {{.PrimaryKeyField.Type}}, p {{.PatchName}}) (*{{.Name}}, error) {
	var qb endo.Builder
	{{- if .UpdatedAtField }}
	qb.WriteWithArgs("UPDATE {{.Table}} SET {{.UpdatedAtField.Column}} = $1", time.Now())
	{{- else -}}
	qb.Write("UPDATE {{.Table}} SET {{.PrimaryKeyField.Column}} = {{.PrimaryKeyField.Column}}")
	{{- end }}

	{{range .PatchFields}}
	if p.{{.Name}} != nil {
		qb.WriteWithPlaced(", {{.Column}} = ?", *p.{{.Name}})
	}
	{{- end}}
	qb.WriteWithPlaced(" WHERE {{.PrimaryKeyField.Column}} = ?", primaryKey)
	// qb.Write(" LIMIT 1") ???
	qb.Write(" ").Write(queryReturning{{.Name}})
	query, args := qb.Build()

	var e {{.Name}}
	err := r.tx(ctx, endo.TxMutation, func (db endo.DBTX) error {
		return scan{{.Name}}(&e, db.QueryRowContext(ctx, query, args...))
	})
	if err != nil {
		return nil, err
	}

	{{if .InvokeOnUpdate}}{{.InvokeOnUpdate}}(ctx, &e){{end}}
	return &e, nil
}
{{end}}

// Update{{.Name}}ByField updates all {{.Plural}} with field `byField` equal to `v`.
func (r *Repository) Update{{.Name}}ByField(ctx context.Context, byField string, v interface{}, p {{.PatchName}}) (*{{.Name}}, error) {
	var qb endo.Builder
	{{- if .UpdatedAtField }}
	qb.WriteWithArgs("UPDATE {{.Table}} SET {{.UpdatedAtField.Column}} = $1", time.Now())
	{{- else -}}
	qb.Write("UPDATE {{.Table}} SET {{.PrimaryKeyField.Column}} = {{.PrimaryKeyField.Column}}")
	{{- end }}

	{{range .PatchFields}}
	if p.{{.Name}} != nil {
		qb.WriteWithPlaced(", {{.Column}} = ?", *p.{{.Name}})
	}
	{{- end}}
	qb.Writef(" WHERE %s", pq.QuoteIdentifier(byField)).WriteWithPlaced(" = ?", v)
	// qb.Write(" LIMIT 1") ???
	qb.Write(" ").Write(queryReturning{{.Name}})
	query, args := qb.Build()

	var e {{.Name}}
	err := r.tx(ctx, endo.TxMutation, func (db endo.DBTX) error {
		return scan{{.Name}}(&e, db.QueryRowContext(ctx, query, args...))
	})
	if err != nil {
		return nil, err
	}

	{{if .InvokeOnUpdate}}{{.InvokeOnUpdate}}(ctx, &e){{end}}
	return &e, nil
}
{{end}}

{{if not .NoDelete}}

{{if .PrimaryKeyField}}
// Delete{{.Name}} deletes the {{.Name}} using the primary key.
func (r *Repository) Delete{{.Name}}(ctx context.Context, primaryKey {{.PrimaryKeyField.Column}}) error {
	const query = "DELETE FROM {{.Table}} WHERE {{.PrimaryKeyField.Column}} = $1"

	return r.tx(ctx, endo.TxMutation, func(db endo.DBTX) error {
		_, err := db.ExecContext(ctx, query, primaryKey)
		return err
	})
}
{{end}}

// Delete{{.Name}}ByField deletes all {{.Plural}} with field `byField` equal to `v`.
func (r *Repository) Delete{{.Name}}ByField(ctx context.Context, byField string, v interface{}) error {
	var qb endo.Builder
	query := qb.
		Write("DELETE FROM {{.Table}}").
		Writef(" WHERE %s = $1", pq.QuoteIdentifier(byField)).
		String()
	return r.tx(ctx, endo.TxMutation, func(db endo.DBTX) error {
		_, err := db.ExecContext(ctx, query, v)
		return err
	})
}
{{end}}

func scan{{.Name}}(e *{{.Name}}, s endo.Scanner) error {
	return s.Scan(
		{{- range .Fields }}
		&e.{{.Name}},
		{{- end }}
	)
}

{{end}}
