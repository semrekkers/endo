// Code generated by endogen; DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"database/sql"

	"github.com/semrekkers/endo/pkg/endo"

{{range .ExtraImports}}	{{.}}
{{end}})

{{if .GenerateStore}}
// {{.Store}} manages the set of APIs for database access.
type {{.Store}} struct {
	tx endo.TxFunc
}

// New{{.Store}} creates a new {{.Store}}.
func New{{.Store}}(tx endo.TxFunc) *{{.Store}} {
	return &{{.Store}}{
		tx: tx,
	}
}
{{end}}

{{- $store := .Store -}}
{{- $readOnly := .ReadOnly -}}
{{range .Models}}

const (
	querySelect{{.Name}} = `{{template "querySelect" .}} `
	queryReturning{{.Name}} = ` {{template "queryReturning" .}}`
)

{{if .PrimaryKey}}
// Get{{.Name}} finds the {{.Name}} identified by the given key.
func (s *{{$store}}) Get{{.Name}}(ctx context.Context, key {{.PrimaryKey.Type}}) (*{{.Type}}, error) {
	const query = querySelect{{.Name}} + "WHERE {{.PrimaryKey.Column}} = $1"

	var e {{.Type}}
	err := s.tx(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query, key)
		return scan{{.Name}}(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}
{{end}}

// Get{{.Name}}ByField finds the {{.Name}} where field equals v.
// Please be aware that field is not protected against SQL injection attacks.
func (s *{{$store}}) Get{{.Name}}ByField(ctx context.Context, field string, v interface{}) (*{{.Type}}, error) {
	var qb endo.Builder
	query := qb.
		Write(querySelect{{.Name}}).
		Writef("WHERE %s = $1", field).
		String()

	var e {{.Type}}
	err := s.tx(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query, v)
		return scan{{.Name}}(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// Get{{.Plural}} gets all {{.Plural}} from the database.
func (s *{{$store}}) Get{{.Plural}}(ctx context.Context, po endo.PageOptions) ([]*{{.Type}}, error) {
	const query = querySelect{{.Name}} +
	{{- if .OrderBy -}}
		"ORDER BY {{ .OrderBy }} " +
	{{- end -}}
	"LIMIT $1 OFFSET $2"
	limit, offset := po.Args()

	var c []*{{.Type}}
	err := s.tx(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		rows, err := dbtx.QueryContext(ctx, query, limit, offset)
		if err != nil {
			return err
		}
		defer rows.Close()
		c, err = scan{{.Name}}Rows(rows)
		return err
	})
	if err != nil {
		return nil, err
	}

	return c, nil
}

{{if not $readOnly}}

// Create{{.Name}} adds {{.Name}} to the database. It returns the created {{.Name}}.
func (s *{{$store}}) Create{{.Name}}(ctx context.Context, e {{.Type}}) (*{{.Type}}, error) {
	const query = `{{template "queryInsert" .}} ` +
		queryReturning{{.Name}}
	
	err := s.tx(ctx, endo.TxMutation, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query,
			{{- range .FieldsNoPrimaryKey }}
			e.{{.Name}},
			{{- end }}
		)
		return scan{{.Name}}(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

{{if .PrimaryKey}}
// Update{{.Name}} updates the {{.Name}} identified by the given key.
func (s *{{$store}}) Update{{.Name}}(ctx context.Context, key {{.PrimaryKey.Type}}, e {{.Type}}) (*{{.Type}}, error) {
	const query = `{{template "queryUpdate" .}} WHERE {{.PrimaryKey.Column}} = ${{ lastArg (.FieldsNoPrimaryKey | toColumns) }} ` +
		queryReturning{{.Name}}

	err := s.tx(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query,
			{{- range .FieldsNoPrimaryKey }}
			e.{{.Name}},
			{{- end }}
			key,
		)
		return scan{{.Name}}(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}
{{end}}

// Update{{.Name}}ByField updates the {{.Name}} to the given e where field equals v.
// Please be aware that field is not protected against SQL injection attacks.
func (s *{{$store}}) Update{{.Name}}ByField(ctx context.Context, field string, v interface{}, e {{.Type}}) (*{{.Type}}, error) {
	var qb endo.Builder
	query := qb.
		Write(`{{template "queryUpdate" .}} `).
		Writef("WHERE %s = ${{ lastArg (.FieldsNoPrimaryKey | toColumns) }} ", field).
		Write(queryReturning{{.Name}}).
		String()

	err := s.tx(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query,
			{{- range .FieldsNoPrimaryKey }}
			e.{{.Name}},
			{{- end }}
			v,
		)
		return scan{{.Name}}(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// {{.PatchType}} can (partially) patch a {{.Type}}.
type {{.PatchType}} struct {
{{- range .FieldsNoPrimaryKey}}
	{{.Name}}	*{{.Type}}
{{- end}}
}

{{if .PrimaryKey}}
// Patch{{.Name}} updates the {{.Name}} identified by the given key, using the patch p.
func (s *{{$store}}) Patch{{.Name}}(ctx context.Context, key {{.PrimaryKey.Type}}, p {{.PatchType}}) (*{{.Type}}, error) {
	var fieldUpdates []endo.NameValue
	{{range .FieldsNoPrimaryKey}}
	if p.{{.Name}} != nil {
		fieldUpdates = append(fieldUpdates, endo.NameValue{
			Name:  "{{.Column}}",
			Value: *p.{{.Name}},
		})
	}
	{{- end}}
	if len(fieldUpdates) == 0 {
		return nil, endo.ErrNoChange
	}

	var qb endo.Builder
	query, args := qb.
		Write("UPDATE {{.Table}} SET ").
		WriteNameValues("%s = ?", ", ", fieldUpdates...).
		WriteWithPlaced(" {{.PrimaryKey.Column}} = ? ", key).
		Write(queryReturning{{.Name}}).
		Build()

	var e {{.Type}}
	err := s.tx(ctx, endo.TxMutation, func (dbtx endo.DBTX) error {
		return scan{{.Name}}(&e, dbtx.QueryRowContext(ctx, query, args...))
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}
{{end}}

// Patch{{.Name}}ByField updates the {{.Name}} using the given patch p where field equals v.
// Please be aware that field is not protected against SQL injection attacks.
func (s *{{$store}}) Patch{{.Name}}ByField(ctx context.Context, field string, v interface{}, p {{.PatchType}}) (*{{.Type}}, error) {
	var fieldUpdates []endo.NameValue
	{{range .FieldsNoPrimaryKey}}
	if p.{{.Name}} != nil {
		fieldUpdates = append(fieldUpdates, endo.NameValue{
			Name:  "{{.Column}}",
			Value: *p.{{.Name}},
		})
	}
	{{- end}}
	if len(fieldUpdates) == 0 {
		return nil, endo.ErrNoChange
	}

	var qb endo.Builder
	query, args := qb.
		Write("UPDATE {{.Table}} SET ").
		WriteNameValues("%s = ?", ", ", fieldUpdates...).
		Writef(" WHERE %s", field).WriteWithPlaced(" = ? ", v).
		Write(queryReturning{{.Name}}).
		Build()

	var e {{.Type}}
	err := s.tx(ctx, endo.TxMutation, func (dbtx endo.DBTX) error {
		return scan{{.Name}}(&e, dbtx.QueryRowContext(ctx, query, args...))
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

{{if .PrimaryKey}}
// Delete{{.Name}} deletes the {{.Name}} identified by the given key.
func (s *{{$store}}) Delete{{.Name}}(ctx context.Context, key {{.PrimaryKey.Type}}) error {
	const query = "DELETE FROM {{.Table}} WHERE {{.PrimaryKey.Column}} = $1"

	return s.tx(ctx, endo.TxMutation, func(dbtx endo.DBTX) error {
		_, err := dbtx.ExecContext(ctx, query, key)
		return err
	})
}
{{end}}

// Delete{{.Name}}ByField deletes the {{.Name}} where field equals v.
// Please be aware that field is not protected against SQL injection attacks.
func (s *{{$store}}) Delete{{.Name}}ByField(ctx context.Context, field string, v interface{}) error {
	var qb endo.Builder
	query := qb.
		Write("DELETE FROM {{.Table}}").
		Writef(" WHERE %s = $1", field).
		String()
	return s.tx(ctx, endo.TxMutation, func(dbtx endo.DBTX) error {
		_, err := dbtx.ExecContext(ctx, query, v)
		return err
	})
}

{{end}}

func scan{{.Name}}(e *{{.Type}}, s endo.Scanner) error {
	return s.Scan(
		{{- range .Fields }}
		&e.{{.Name}},
		{{- end }}
	)
}

func scan{{.Name}}Rows(rows *sql.Rows) ([]*{{.Type}}, error) {
	var c []*{{.Type}}
	for rows.Next() {
		var e {{.Type}}
		if err := scan{{.Name}}(&e, rows); err != nil {
			return nil, err
		}
		c = append(c, &e)
	}
	return c, nil
}

{{end}}
