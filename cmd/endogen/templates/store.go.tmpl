// Code generated by endogen; DO NOT EDIT.

package {{.Package}}

import (
	{{ range .Imports -}}
	{{.Spec}}
	{{end}})

{{if .GenerateStore}}
// {{.Store}} manages the set of APIs for database access.
type {{.Store}} struct {
	TX endo.TxFunc
}
{{end}}

{{- $store := .Store -}}
{{- $patchTypeMode := .PatchTypeMode -}}
{{range .Models}}

const (
	querySelect{{.Name}} = `{{template "querySelect" .}} `
	queryReturn{{.Name}} = ` {{template "queryReturning" .}}`
	querySort{{.Name}} = `{{if .Sort}} ORDER BY {{.Sort}} {{end}}`
)

// Get{{.Name}} retrieves the first {{.Name}} with the filters applied. The default sorting of {{.Name}} is used.
func (s *{{$store}}) Get{{.Name}}(ctx context.Context, filters ...endo.KeyValue) (*{{.PackagePrefix}}{{.Type}}, error) {
	var qb endo.Builder
	qb.Write(querySelect{{.Name}})
	if 0 < len(filters) {
		qb.Write("WHERE ").WriteKeyValues("(%s)", " AND ", filters...).Write(" ")
	}
	qb.Write({{if .Sort}} querySort{{.Name}} + {{end}} "LIMIT 1")
	query, args := qb.Build()

	var e {{.PackagePrefix}}{{.Type}}
	err := s.TX(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query, args...)
		return scan{{.Name}}(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// Get{{.Plural}} retrieves all {{.Plural}} with the filters applied, within the bounds of the page.
// The default sorting of {{.Name}} is used.
func (s *{{$store}}) Get{{.Plural}}(ctx context.Context, po endo.PageOptions, filters ...endo.KeyValue) ([]*{{.PackagePrefix}}{{.Type}}, error) {
	var qb endo.Builder
	qb.Write(querySelect{{.Name}})
	if 0 < len(filters) {
		qb.Write("WHERE ").WriteKeyValues("(%s)", " AND ", filters...).Write(" ")
	}
	{{ if .Sort -}}
	qb.Write(querySort{{.Name}})
	{{ end -}}
	limit, offset := po.Args()
	qb.WriteWithParams("LIMIT {} OFFSET {}", limit, offset)
	query, args := qb.Build()

	var c []*{{.PackagePrefix}}{{.Type}}
	err := s.TX(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		rows, err := dbtx.QueryContext(ctx, query, args...)
		if err != nil {
			return err
		}
		defer rows.Close()
		c, err = scan{{.Name}}Rows(rows)
		return err
	})

	return c, err
}

{{if not .ReadOnly}}

// Create{{.Name}} inserts a {{.Name}} record. On success, it returns the created record.
func (s *{{$store}}) Create{{.Name}}(ctx context.Context, e {{.PackagePrefix}}{{.Type}}) (*{{.PackagePrefix}}{{.Type}}, error) {
	const query = `{{template "queryInsert" .}} ` +
		queryReturn{{.Name}}
	
	err := s.TX(ctx, endo.TxMutation, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query,
			{{- range .Fields true }}
			e.{{.Name}},
			{{- end }}
		)
		return scan{{.Name}}(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

{{if not .Immutable}}

// Update{{.Name}} updates the first {{.Name}} with the filters applied. The default sorting of {{.Name}} is used.
// On success, it returns the updated record.
func (s *{{$store}}) Update{{.Name}}(ctx context.Context, e {{.PackagePrefix}}{{.Type}}, filters ...endo.KeyValue) (*{{.PackagePrefix}}{{.Type}}, error) {
	var qb endo.Builder
	qb.WriteWithArgs(`{{template "queryUpdate" .}} `,
		{{- range .Fields true }}
		e.{{.Name}},
		{{- end }}
	)
	if 0 < len(filters) {
		qb.Write("WHERE ").WriteKeyValues("(%s)", " AND ", filters...).Write(" ")
	}
	qb.Write({{if .Sort}} querySort{{.Name}} + {{end}} "LIMIT 1" + queryReturn{{.Name}})
	query, args := qb.Build()

	err := s.TX(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query, args...)
		return scan{{.Name}}(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

{{if eq $patchTypeMode "include"}}
{{template "patchType" .}}
{{end}}

// Patch{{.Name}} updates the first {{.Name}} using patch with the filters applied. The default sorting of {{.Name}} is used.
// On success, it returns the updated record.
func (s *{{$store}}) Patch{{.Name}}(ctx context.Context, p {{.Patch.PackagePrefix}}{{.Patch.Type}}, filters ...endo.KeyValue) (*{{.PackagePrefix}}{{.Type}}, error) {
	var fieldUpdates []endo.KeyValue
	{{range .Patch.Fields true}}
	if p.{{.Name}} != nil {
		fieldUpdates = append(fieldUpdates, endo.KeyValue{
			Key:   `{{.Column}}`,
			Value: *p.{{.Name}},
		})
	}
	{{- end}}
	if len(fieldUpdates) < 1 {
		return nil, endo.ErrEmptyUpdate
	}

	var qb endo.Builder
	qb.Write(`UPDATE {{.Table}} SET `).WriteKeyValues("%s = {}", ", ", fieldUpdates...).Write(" ")
	if 0 < len(filters) {
		qb.Write("WHERE ").WriteKeyValues("(%s)", " AND ", filters...).Write(" ")
	}
	qb.Write({{if .Sort}} querySort{{.Name}} + {{end}} "LIMIT 1" + queryReturn{{.Name}})
	query, args := qb.Build()

	var e {{.PackagePrefix}}{{.Type}}
	err := s.TX(ctx, endo.TxMutation, func (dbtx endo.DBTX) error {
		return scan{{.Name}}(&e, dbtx.QueryRowContext(ctx, query, args...))
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}
{{end}}

// Delete{{.Name}} deletes the first {{.Name}} with the filters applied. The default sorting of {{.Name}} is used.
func (s *{{$store}}) Delete{{.Name}}(ctx context.Context, filters ...endo.KeyValue) error {
	var qb endo.Builder
	qb.Write(`DELETE FROM {{.Table}} `)
	if 0 < len(filters) {
		qb.Write("WHERE ").WriteKeyValues("(%s)", " AND ", filters...).Write(" ")
	}
	qb.Write({{if .Sort}} querySort{{.Name}} + {{end}} "LIMIT 1")
	query, args := qb.Build()

	return s.TX(ctx, endo.TxMutation, func(dbtx endo.DBTX) error {
		_, err := dbtx.ExecContext(ctx, query, args...)
		return err
	})
}

{{end}}

func scan{{.Name}}(e *{{.PackagePrefix}}{{.Type}}, s endo.Scanner) error {
	return s.Scan(
		{{- range .Fields false }}
		&e.{{.Name}},
		{{- end }}
	)
}

func scan{{.Name}}Rows(rows *sql.Rows) ([]*{{.PackagePrefix}}{{.Type}}, error) {
	var c []*{{.PackagePrefix}}{{.Type}}
	for rows.Next() {
		var e {{.PackagePrefix}}{{.Type}}
		if err := scan{{.Name}}(&e, rows); err != nil {
			return nil, err
		}
		c = append(c, &e)
	}
	return c, nil
}

{{end}}
