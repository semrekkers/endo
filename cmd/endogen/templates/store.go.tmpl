// Code generated by endogen; DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"database/sql"

	"github.com/semrekkers/endo/pkg/endo"

	{{if .ModelsImportPath}}{{.ModelsImportAlias}} "{{.ModelsImportPath}}"{{end}}

{{range .ExtraImports}}	{{.}}
{{end}})

{{if .GenerateStore}}
// {{.Store}} manages the set of APIs for database access.
type {{.Store}} struct {
	TX endo.TxFunc
}
{{end}}

{{- $store := .Store -}}
{{- $patchTypeMode := .PatchTypeMode -}}
{{range .Models}}

const (
	querySelect{{.Name}} = `{{template "querySelect" .}} `
	queryReturning{{.Name}} = ` {{template "queryReturning" .}}`
)

{{if .PrimaryKey}}
// Get{{.Name}} finds the {{.Name}} identified by the given key.
func (s *{{$store}}) Get{{.Name}}(ctx context.Context, key {{.PrimaryKey.Type}}) (*{{.PackagePrefix}}{{.Type}}, error) {
	const query = querySelect{{.Name}} + "WHERE {{.PrimaryKey.Column}} = $1"

	var e {{.PackagePrefix}}{{.Type}}
	err := s.TX(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query, key)
		return scan{{.Name}}(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}
{{end}}

// Get{{.Name}}ByField finds the {{.Name}} where field equals v.
// Please be aware that field is not protected against SQL injection attacks.
func (s *{{$store}}) Get{{.Name}}ByField(ctx context.Context, field string, v interface{}) (*{{.PackagePrefix}}{{.Type}}, error) {
	var qb endo.Builder
	query := qb.
		Write(querySelect{{.Name}}).
		Writef("WHERE %s = $1", field).
		String()

	var e {{.PackagePrefix}}{{.Type}}
	err := s.TX(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query, v)
		return scan{{.Name}}(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// Get{{.Plural}} gets all {{.Plural}} from the database.
func (s *{{$store}}) Get{{.Plural}}(ctx context.Context, po endo.PageOptions) ([]*{{.PackagePrefix}}{{.Type}}, error) {
	const query = querySelect{{.Name}} +
	{{- if .OrderBy -}}
		"ORDER BY {{ .OrderBy }} " +
	{{- end -}}
	"LIMIT $1 OFFSET $2"
	limit, offset := po.Args()

	var c []*{{.PackagePrefix}}{{.Type}}
	err := s.TX(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		rows, err := dbtx.QueryContext(ctx, query, limit, offset)
		if err != nil {
			return err
		}
		defer rows.Close()
		c, err = scan{{.Name}}Rows(rows)
		return err
	})
	if err != nil {
		return nil, err
	}

	return c, nil
}

// Get{{.Plural}}Filtered gets all {{.Plural}} with filters applied, from the database.
func (s *{{$store}}) Get{{.Plural}}Filtered(ctx context.Context, po endo.PageOptions, filters ...endo.NamedArg) ([]*{{.PackagePrefix}}{{.Type}}, error) {
	var qb endo.Builder
	qb.Write(querySelect{{.Name}})
	if 0 < len(filters) {
		qb.Write("WHERE ").WriteNamedArgs("(%s)", " AND ", filters...).Write(" ")
	}
	{{ if .OrderBy -}}
	qb.Write("ORDER BY {{ .OrderBy }} ")
	{{ end -}}
	limit, offset := po.Args()
	qb.WriteWithParams("LIMIT {} OFFSET {}", limit, offset)
	query, args := qb.Build()

	var c []*{{.PackagePrefix}}{{.Type}}
	err := s.TX(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		rows, err := dbtx.QueryContext(ctx, query, args...)
		if err != nil {
			return err
		}
		defer rows.Close()
		c, err = scan{{.Name}}Rows(rows)
		return err
	})

	return c, err
}

{{if not .ReadOnly}}

// Create{{.Name}} adds {{.Name}} to the database. It returns the created {{.Name}}.
func (s *{{$store}}) Create{{.Name}}(ctx context.Context, e {{.PackagePrefix}}{{.Type}}) (*{{.PackagePrefix}}{{.Type}}, error) {
	const query = `{{template "queryInsert" .}} ` +
		queryReturning{{.Name}}
	
	err := s.TX(ctx, endo.TxMutation, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query,
			{{- range .Fields true }}
			e.{{.Name}},
			{{- end }}
		)
		return scan{{.Name}}(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

{{if not .Immutable}}
{{if .PrimaryKey}}
// Update{{.Name}} updates the {{.Name}} identified by the given key.
func (s *{{$store}}) Update{{.Name}}(ctx context.Context, key {{.PrimaryKey.Type}}, e {{.PackagePrefix}}{{.Type}}) (*{{.PackagePrefix}}{{.Type}}, error) {
	const query = `{{template "queryUpdate" .}} WHERE {{.PrimaryKey.Column}} = ${{ lastArg (.Fields true | toColumns) }} ` +
		queryReturning{{.Name}}

	err := s.TX(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query,
			{{- range .Fields true }}
			e.{{.Name}},
			{{- end }}
			key,
		)
		return scan{{.Name}}(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}
{{end}}

// Update{{.Name}}ByField updates the {{.Name}} to the given e where field equals v.
// Please be aware that field is not protected against SQL injection attacks.
func (s *{{$store}}) Update{{.Name}}ByField(ctx context.Context, field string, v interface{}, e {{.PackagePrefix}}{{.Type}}) (*{{.PackagePrefix}}{{.Type}}, error) {
	var qb endo.Builder
	query := qb.
		Write(`{{template "queryUpdate" .}} `).
		Writef("WHERE %s = ${{ lastArg (.Fields true | toColumns) }} ", field).
		Write(queryReturning{{.Name}}).
		String()

	err := s.TX(ctx, endo.TxReadOnly, func(dbtx endo.DBTX) error {
		row := dbtx.QueryRowContext(ctx, query,
			{{- range .Fields true }}
			e.{{.Name}},
			{{- end }}
			v,
		)
		return scan{{.Name}}(&e, row)
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}

{{if eq $patchTypeMode "include"}}
{{template "patchType" .}}
{{end}}

{{if .PrimaryKey}}
// Patch{{.Name}} updates the {{.Name}} identified by the given key, using the patch p.
func (s *{{$store}}) Patch{{.Name}}(ctx context.Context, key {{.PrimaryKey.Type}}, p {{.PatchType}}) (*{{.PackagePrefix}}{{.Type}}, error) {
	var fieldUpdates []endo.NamedArg
	{{range .Fields true}}
	if p.{{.Name}} != nil {
		fieldUpdates = append(fieldUpdates, endo.NamedArg{
			Name:  "{{.Column}}",
			Value: *p.{{.Name}},
		})
	}
	{{- end}}
	if len(fieldUpdates) == 0 {
		return nil, endo.ErrNoChange
	}

	var qb endo.Builder
	query, args := qb.
		Write("UPDATE {{.Table}} SET ").
		WriteNamedArgs("%s = {}", ", ", fieldUpdates...).
		WriteWithParams(" WHERE {{.PrimaryKey.Column}} = {} ", key).
		Write(queryReturning{{.Name}}).
		Build()

	var e {{.PackagePrefix}}{{.Type}}
	err := s.TX(ctx, endo.TxMutation, func (dbtx endo.DBTX) error {
		return scan{{.Name}}(&e, dbtx.QueryRowContext(ctx, query, args...))
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}
{{end}}

// Patch{{.Name}}ByField updates the {{.Name}} using the given patch p where field equals v.
// Please be aware that field is not protected against SQL injection attacks.
func (s *{{$store}}) Patch{{.Name}}ByField(ctx context.Context, field string, v interface{}, p {{.PatchType}}) (*{{.PackagePrefix}}{{.Type}}, error) {
	var fieldUpdates []endo.NamedArg
	{{range .Fields true}}
	if p.{{.Name}} != nil {
		fieldUpdates = append(fieldUpdates, endo.NamedArg{
			Name:  "{{.Column}}",
			Value: *p.{{.Name}},
		})
	}
	{{- end}}
	if len(fieldUpdates) == 0 {
		return nil, endo.ErrNoChange
	}

	var qb endo.Builder
	query, args := qb.
		Write("UPDATE {{.Table}} SET ").
		WriteNamedArgs("%s = {}", ", ", fieldUpdates...).
		Writef(" WHERE %s", field).WriteWithParams(" = {} ", v).
		Write(queryReturning{{.Name}}).
		Build()

	var e {{.PackagePrefix}}{{.Type}}
	err := s.TX(ctx, endo.TxMutation, func (dbtx endo.DBTX) error {
		return scan{{.Name}}(&e, dbtx.QueryRowContext(ctx, query, args...))
	})
	if err != nil {
		return nil, err
	}

	return &e, nil
}
{{end}}

{{if .PrimaryKey}}
// Delete{{.Name}} deletes the {{.Name}} identified by the given key.
func (s *{{$store}}) Delete{{.Name}}(ctx context.Context, key {{.PrimaryKey.Type}}) error {
	const query = "DELETE FROM {{.Table}} WHERE {{.PrimaryKey.Column}} = $1"

	return s.TX(ctx, endo.TxMutation, func(dbtx endo.DBTX) error {
		_, err := dbtx.ExecContext(ctx, query, key)
		return err
	})
}
{{end}}

// Delete{{.Name}}ByField deletes the {{.Name}} where field equals v.
// Please be aware that field is not protected against SQL injection attacks.
func (s *{{$store}}) Delete{{.Name}}ByField(ctx context.Context, field string, v interface{}) error {
	var qb endo.Builder
	query := qb.
		Write("DELETE FROM {{.Table}}").
		Writef(" WHERE %s = $1", field).
		String()
	return s.TX(ctx, endo.TxMutation, func(dbtx endo.DBTX) error {
		_, err := dbtx.ExecContext(ctx, query, v)
		return err
	})
}

{{end}}

func scan{{.Name}}(e *{{.PackagePrefix}}{{.Type}}, s endo.Scanner) error {
	return s.Scan(
		{{- range .Fields false }}
		&e.{{.Name}},
		{{- end }}
	)
}

func scan{{.Name}}Rows(rows *sql.Rows) ([]*{{.PackagePrefix}}{{.Type}}, error) {
	var c []*{{.PackagePrefix}}{{.Type}}
	for rows.Next() {
		var e {{.PackagePrefix}}{{.Type}}
		if err := scan{{.Name}}(&e, rows); err != nil {
			return nil, err
		}
		c = append(c, &e)
	}
	return c, nil
}

{{end}}
